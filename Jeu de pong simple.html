<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Snake Moderne</title>
    <!-- Chargement de Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configuration Tailwind pour les couleurs personnalis√©es -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-neon': '#4cc9f0', // Bleu/Cyan
                        'secondary-neon': '#f72585', // Rose/Magenta
                        'bg-dark': '#1a1a2e', // Fond fonc√© principal
                        'game-bg': '#0f0f1a', // Fond du canvas
                        'snake-color': '#7209b7', // Violet
                        'food-color': '#f72585', // Rose
                        'grid-color': 'rgba(76, 201, 240, 0.15)',
                    }
                }
            }
        }
    </script>
    <style>
        /* D√©finition de la police Inter et style de base */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            /* Layout de base pour centrer tout */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        /* Conteneur principal du jeu (Canvas + Affichages) */
        #game-area-wrapper {
            max-width: 500px; /* Taille fixe pour le canvas */
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-container {
            width: 100%;
            height: 500px; /* Hauteur fixe pour le canvas */
            box-shadow: 0 0 40px rgba(76, 201, 240, 0.2);
            transition: transform 0.3s ease-in-out;
        }

        /* Score/Record/Level Bar positioning inside the game container */
        .info-bar {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: rgba(15, 15, 26, 0.8);
            border-bottom: 2px solid #3a0ca3;
            border-top-left-radius: 10px;
            border-top-right-radius: 10px;
            z-index: 50; /* Au-dessus du canvas mais sous les messages */
        }
        
        /* Boutons et Messages */
        .neon-btn {
            padding: 12px 30px;
            border-radius: 50px;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 700;
        }

        #play-btn {
            background: linear-gradient(45deg, #4cc9f0, #3a0ca3);
            border: 2px solid #4cc9f0;
            box-shadow: 0 0 15px rgba(76, 201, 240, 0.6), 0 4px 15px rgba(0, 0, 0, 0.3);
            color: white;
        }
        #play-btn:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 0 25px rgba(76, 201, 240, 0.8), 0 8px 20px rgba(0, 0, 0, 0.5);
        }

        #restart-btn {
            background: linear-gradient(45deg, #f72585, #7209b7);
            border: 2px solid #f72585;
            box-shadow: 0 0 15px rgba(247, 37, 133, 0.6);
            color: white;
        }
        #restart-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow: 0 0 25px rgba(247, 37, 133, 0.8);
        }

        /* Styles pour le Mobile/Touch (Obligatoire sur mobile) */
        #touch-controls {
            display: none; /* Cach√© par d√©faut */
            margin-top: 20px;
        }

        .touch-btn {
            background-color: rgba(76, 201, 240, 0.1);
            color: #4cc9f0;
            border: 1px solid #4cc9f0;
            box-shadow: 0 0 10px rgba(76, 201, 240, 0.3);
            transition: background-color 0.1s;
        }
        .touch-btn:active {
            background-color: rgba(76, 201, 240, 0.5);
        }

        /* MEDIA QUERIES pour l'adaptabilit√© mobile */
        @media (max-width: 767px) {
            /* Afficher les contr√¥les tactiles sur tous les petits √©crans */
            #touch-controls {
                display: flex;
            }
            body {
                /* Permet au contenu de s'adapter verticalement */
                flex-direction: column;
                min-height: 100dvh; /* Utilisation de dvh pour une meilleure compatibilit√© mobile */
            }
            #game-area-wrapper {
                /* Permet de r√©duire la taille du canvas sur les petits √©crans */
                max-width: 90vw;
                height: auto;
            }
            #game-container {
                 /* Adapter la taille du conteneur carr√© √† la largeur disponible */
                width: 100%;
                height: 100vw; /* Utiliser la largeur de la fen√™tre pour conserver un ratio 1:1 */
                max-height: 90vw;
                max-width: 100%;
            }

            /* Disposition en mode Paysage (Mobile) */
            @media (orientation: landscape) {
                body {
                    flex-direction: row;
                    justify-content: space-evenly;
                    align-items: center;
                    padding: 10px;
                }
                #game-area-wrapper {
                    max-width: 45vw; /* Le jeu prend moins de la moiti√© de l'√©cran */
                    max-height: 90vh;
                }
                #game-container {
                    width: 100%;
                    height: 100%;
                    max-height: 80vh; /* Limite la hauteur du canvas */
                    /* Le canvas sera mis √† jour en JS */
                }
                #touch-controls {
                    /* Les contr√¥les prennent l'autre moiti√© et sont dispos√©s verticalement */
                    max-width: 45vw;
                    margin-top: 0;
                    margin-left: 20px;
                    flex-direction: column;
                    align-items: center;
                }
                .touch-row {
                    display: flex;
                    justify-content: center;
                }
            }
        }
    </style>
</head>
<body class="bg-bg-dark flex justify-center items-center h-screen text-white p-4">

    <!-- Wrapper pour le jeu et les affichages -->
    <div id="game-area-wrapper">
        <!-- Conteneur principal du jeu (500x500) -->
        <div id="game-container" class="relative bg-game-bg rounded-xl shadow-2xl flex justify-center items-center flex-col md:p-0">

            <!-- Menu de D√©marrage -->
            <div id="menu" class="text-center p-8 z-50">
                <div id="title" class="text-6xl font-extrabold mb-10 text-primary-neon tracking-wider" style="text-shadow: 0 0 20px rgba(76, 201, 240, 0.7);">SNAKE üêç</div>
                
                <div id="difficulty" class="mb-8 p-4 bg-bg-dark rounded-lg shadow-inner">
                    <p class="text-lg mb-4 text-gray-300">Choisissez la difficult√© :</p>
                    <label class="mx-3 text-lg cursor-pointer">
                        <input type="radio" name="difficulty" value="easy" checked class="text-primary-neon focus:ring-primary-neon"> Facile
                    </label>
                    <label class="mx-3 text-lg cursor-pointer">
                        <input type="radio" name="difficulty" value="medium" class="text-primary-neon focus:ring-primary-neon"> Moyen
                    </label>
                    <label class="mx-3 text-lg cursor-pointer">
                        <input type="radio" name="difficulty" value="hard" class="text-primary-neon focus:ring-primary-neon"> Difficile
                    </label>
                </div>
                <button id="play-btn" class="neon-btn">
                    D√©marrer le Jeu
                </button>
                <p class="text-sm mt-4 text-gray-500 hidden md:block">Utilisez les touches ‚¨ÜÔ∏è‚¨áÔ∏è‚¨ÖÔ∏è‚û°Ô∏è ou la barre d'espace pour Pause</p>
                <p class="text-sm mt-4 text-gray-500 md:hidden">Utilisez les contr√¥les ci-dessous pour jouer.</p>
            </div>

            <!-- Barre d'informations (Score, Record, Niveau) -->
            <div class="info-bar">
                <div id="score-display" class="text-lg font-bold text-primary-neon" style="text-shadow: 0 0 5px rgba(76, 201, 240, 0.5);">Score: 0</div>
                <div id="record-display" class="text-lg font-bold text-white" style="text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);">Record: 0</div>
                <div id="level-display" class="text-lg font-bold text-secondary-neon" style="text-shadow: 0 0 5px rgba(247, 37, 133, 0.5);">Niveau: 1</div>
            </div>

            <!-- Canvas de Jeu -->
            <canvas id="game-canvas" width="500" height="500" class="rounded-xl mt-12"></canvas>
            
            <!-- Messages Overlay -->
            <div id="pause-message" class="absolute inset-0 bg-black bg-opacity-70 flex justify-center items-center text-5xl font-extrabold text-secondary-neon rounded-xl" style="display: none; z-index: 100;">
                PAUSE
                <span class="absolute bottom-10 text-xl text-gray-400">Appuyez sur ESPACE pour reprendre (PC)</span>
            </div>
            
            <div id="game-over-message" class="absolute inset-0 bg-black bg-opacity-80 flex justify-center items-center flex-col text-center text-5xl font-extrabold text-secondary-neon rounded-xl" style="display: none; z-index: 100;">
                GAME OVER !
                <div id="final-score" class="text-3xl mt-4 text-primary-neon">Score final: 0</div>
                <button id="restart-btn" class="neon-btn mt-6">
                    Recommencer
                </button>
            </div>
        </div>
    </div>
    
    <!-- Contr√¥les Tactiles (Affich√©s uniquement sur mobile) -->
    <div id="touch-controls" class="flex flex-col items-center w-full max-w-sm">
        <div class="touch-row flex">
            <button id="touch-up" class="touch-btn p-4 rounded-full w-16 h-16 m-1 text-2xl">‚¨ÜÔ∏è</button>
        </div>
        <div class="touch-row flex justify-center">
            <button id="touch-left" class="touch-btn p-4 rounded-full w-16 h-16 m-1 text-2xl">‚¨ÖÔ∏è</button>
            <button id="touch-pause" class="touch-btn p-4 rounded-full w-16 h-16 m-1 text-secondary-neon text-2xl font-bold">II</button>
            <button id="touch-right" class="touch-btn p-4 rounded-full w-16 h-16 m-1 text-2xl">‚û°Ô∏è</button>
        </div>
        <div class="touch-row flex">
            <button id="touch-down" class="touch-btn p-4 rounded-full w-16 h-16 m-1 text-2xl">‚¨áÔ∏è</button>
        </div>
    </div>

    <!-- Audio (Gard√© les m√™mes URLs de Mixkit) -->
    <audio id="background-music" loop>
        <source src="https://assets.mixkit.co/music/preview/mixkit-tech-house-vibes-130.mp3" type="audio/mpeg">
    </audio>
    <audio id="eat-sound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-winning-chimes-2015.mp3" type="audio/mpeg">
    </audio>
    <audio id="game-over-sound">
        <source src="https://assets.mixkit.co/sfx/preview/mixkit-sad-game-over-443.mp3" type="audio/mpeg">
    </audio>

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const menu = document.getElementById('menu');
        const playBtn = document.getElementById('play-btn');
        const restartBtn = document.getElementById('restart-btn');
        const pauseMessage = document.getElementById('pause-message');
        const gameOverMessage = document.getElementById('game-over-message');
        const finalScoreDisplay = document.getElementById('final-score');
        const scoreDisplay = document.getElementById('score-display');
        const recordDisplay = document.getElementById('record-display'); // Nouveau
        const levelDisplay = document.getElementById('level-display');
        const backgroundMusic = document.getElementById('background-music');
        const eatSound = document.getElementById('eat-sound');
        const gameOverSound = document.getElementById('game-over-sound');

        // Commandes tactiles
        const touchControls = {
            up: document.getElementById('touch-up'),
            down: document.getElementById('touch-down'),
            left: document.getElementById('touch-left'),
            right: document.getElementById('touch-right'),
            pause: document.getElementById('touch-pause'),
        };

        // Constantes du jeu
        const GRID_SIZE = 25;
        const TILE_SIZE = 20;

        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let gameLoop;
        let score = 0;
        let highScore = 0; // Nouveau: Record
        let level = 1;
        let gameSpeed = 150;
        let isPaused = false;
        let isGameOver = true;

        /**
         * Met √† jour tous les affichages de score et niveau.
         */
        function updateScoreDisplays() {
            scoreDisplay.textContent = `Score: ${score}`;
            recordDisplay.textContent = `Record: ${highScore}`;
            levelDisplay.textContent = `Niveau: ${level}`;
        }

        /**
         * Initialisation des variables de jeu et de la vitesse.
         */
        function initGame() {
            // Chargement du record depuis le stockage local
            highScore = parseInt(localStorage.getItem('snakeHighScore') || 0);

            const startX = Math.floor(GRID_SIZE / 2) * TILE_SIZE;
            const startY = Math.floor(GRID_SIZE / 2) * TILE_SIZE;

            snake = [
                { x: startX, y: startY },
                { x: startX - TILE_SIZE, y: startY },
                { x: startX - 2 * TILE_SIZE, y: startY }
            ];

            generateFood();
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            level = 1;
            
            updateScoreDisplays();

            isPaused = false;
            isGameOver = false;
            pauseMessage.style.display = 'none';
            gameOverMessage.style.display = 'none';

            // D√©termination de la vitesse initiale
            const difficulty = document.querySelector('input[name="difficulty"]:checked').value;
            switch (difficulty) {
                case 'easy': gameSpeed = 200; break;
                case 'medium': gameSpeed = 150; break;
                case 'hard': gameSpeed = 100; break;
            }
        }

        /**
         * G√©n√®re un nouvel emplacement pour la nourriture.
         */
        function generateFood() {
            let newFood = {};
            let isOverlapping = true;

            while (isOverlapping) {
                newFood = {
                    x: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE,
                    y: Math.floor(Math.random() * GRID_SIZE) * TILE_SIZE
                };
                isOverlapping = snake.some(segment => segment.x === newFood.x && segment.y === newFood.y);
            }
            food = newFood;
        }

        /**
         * Dessine la grille de fond.
         */
        function drawGrid() {
            ctx.strokeStyle = '#3a0ca3'; // Couleur de grille plus visible
            ctx.lineWidth = 1;
            
            for (let i = 0; i <= canvas.width; i += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            for (let i = 0; i <= canvas.height; i += TILE_SIZE) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }

        /**
         * Dessine le serpent avec des coins arrondis et des yeux.
         */
        function drawSnake() {
            snake.forEach((segment, index) => {
                const x = segment.x;
                const y = segment.y;

                ctx.fillStyle = index === 0 ? '#4cc9f0' : '#7209b7';
                ctx.strokeStyle = '#0a0a12';
                ctx.lineWidth = 2;

                ctx.beginPath();
                // Utilisation de la fonction roundRect (n√©cessite un navigateur moderne)
                if (ctx.roundRect) {
                    ctx.roundRect(x, y, TILE_SIZE, TILE_SIZE, 3);
                } else {
                    ctx.rect(x, y, TILE_SIZE, TILE_SIZE);
                }
                ctx.fill();
                ctx.stroke();

                // Yeux pour la t√™te (simplifi√©)
                if (index === 0) {
                    const eyeSize = 3;
                    const offset = 5;
                    ctx.fillStyle = 'white';

                    // Position des yeux bas√©e sur la direction
                    let e1x, e1y, e2x, e2y;
                    if (direction === 'right') { e1x = x + 12; e1y = y + 5; e2x = x + 12; e2y = y + 12; }
                    else if (direction === 'left') { e1x = x + 3; e1y = y + 5; e2x = x + 3; e2y = y + 12; }
                    else if (direction === 'up') { e1x = x + 5; e1y = y + 3; e2x = x + 12; e2y = y + 3; }
                    else if (direction === 'down') { e1x = x + 5; e1y = y + 12; e2x = x + 12; e2y = y + 12; }
                    
                    ctx.fillRect(e1x, e1y, eyeSize, eyeSize);
                    ctx.fillRect(e2x, e2y, eyeSize, eyeSize);
                }
            });
        }

        /**
         * Dessine la nourriture.
         */
        function drawFood() {
            ctx.fillStyle = '#f72585';
            ctx.shadowColor = '#f72585';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(food.x + TILE_SIZE / 2, food.y + TILE_SIZE / 2, TILE_SIZE / 2 * 0.8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        /**
         * Logique de mise √† jour du jeu (mouvement, collisions, score).
         */
        function updateGame() {
            if (isPaused || isGameOver) return;

            direction = nextDirection;
            const head = { x: snake[0].x, y: snake[0].y };

            switch (direction) {
                case 'up': head.y -= TILE_SIZE; break;
                case 'down': head.y += TILE_SIZE; break;
                case 'left': head.x -= TILE_SIZE; break;
                case 'right': head.x += TILE_SIZE; break;
            }

            // 1. Collision avec les murs (t√©l√©portation optionnelle √† consid√©rer pour les modes plus simples, mais ici c'est Game Over)
            if (
                head.x < 0 || head.x >= canvas.width ||
                head.y < 0 || head.y >= canvas.height
            ) {
                gameOver();
                return;
            }

            // 2. Collision avec le corps
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    gameOver();
                    return;
                }
            }

            snake.unshift(head);

            // 3. Collision avec la nourriture
            if (head.x === food.x && head.y === food.y) {
                eatSound.currentTime = 0;
                eatSound.play();
                score += 10;

                // Gestion des niveaux et de la vitesse
                if (score >= level * 50) {
                    level++;
                    
                    const newSpeed = gameSpeed * 0.9;
                    gameSpeed = Math.max(50, newSpeed); // Vitesse minimale de 50ms

                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameLoopFn, gameSpeed);
                }

                updateScoreDisplays();
                generateFood();
            } else {
                // D√©placement normal : suppression de la queue
                snake.pop();
            }
        }

        /**
         * Fonction de boucle de jeu.
         */
        function gameLoopFn() {
            updateGame();
            drawGame();
        }

        /**
         * Fonction de dessin principal.
         */
        function drawGame() {
            ctx.fillStyle = '#0a0a12';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawGrid();
            drawFood();
            drawSnake();
        }

        /**
         * G√®re la pause et la reprise du jeu.
         */
        function togglePause() {
            if (isGameOver) return;

            isPaused = !isPaused;
            pauseMessage.style.display = isPaused ? 'flex' : 'none';

            if (isPaused) {
                backgroundMusic.pause();
                clearInterval(gameLoop);
            } else {
                // Tente de jouer la musique.
                backgroundMusic.play().catch(e => console.log('Music play blocked:', e));
                gameLoop = setInterval(gameLoopFn, gameSpeed);
            }
        }

        /**
         * Fin du jeu.
         */
        function gameOver() {
            isGameOver = true;
            clearInterval(gameLoop);
            backgroundMusic.pause();
            
            gameOverSound.currentTime = 0;
            gameOverSound.play();

            // V√©rification et sauvegarde du Record
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
            }
            
            finalScoreDisplay.textContent = `Score final: ${score} (Record: ${highScore})`;
            gameOverMessage.style.display = 'flex';
            updateScoreDisplays(); // Mise √† jour pour afficher le record potentiel
        }
        
        // --- GESTION DES √âV√âNEMENTS ---

        // Helper pour changer la direction (utilis√© par clavier et tactile)
        function setDirection(dir) {
            if (isGameOver || isPaused) return;

            let newDirection = nextDirection;
            
            if (dir === 'up' && direction !== 'down') newDirection = 'up';
            else if (dir === 'down' && direction !== 'up') newDirection = 'down';
            else if (dir === 'left' && direction !== 'right') newDirection = 'left';
            else if (dir === 'right' && direction !== 'left') newDirection = 'right';

            if (newDirection !== direction) {
                nextDirection = newDirection;
            }
        }

        // 1. Commandes clavier
        document.addEventListener('keydown', (e) => {
            if (isGameOver && e.code !== 'Space') return;

            if (e.code === 'Space') {
                togglePause();
            } else if (!isPaused) {
                switch (e.key) {
                    case 'ArrowUp': setDirection('up'); break;
                    case 'ArrowDown': setDirection('down'); break;
                    case 'ArrowLeft': setDirection('left'); break;
                    case 'ArrowRight': setDirection('right'); break;
                }
            }
        });

        // 2. Commandes du menu et de red√©marrage
        playBtn.addEventListener('click', () => {
            menu.style.display = 'none';
            canvas.style.display = 'block';
            
            initGame();
            backgroundMusic.currentTime = 0;
            backgroundMusic.volume = 0.3;
            backgroundMusic.play().catch(e => console.log('Music play blocked.'));
            
            gameLoop = setInterval(gameLoopFn, gameSpeed);
            drawGame();
            resizeCanvas(); // Ajustement initial
        });

        restartBtn.addEventListener('click', () => {
            initGame();
            backgroundMusic.currentTime = 0;
            backgroundMusic.play().catch(e => console.log('Music play blocked.'));
            gameLoop = setInterval(gameLoopFn, gameSpeed);
        });

        // 3. Commandes Tactiles (Mobile)
        touchControls.up.addEventListener('click', () => setDirection('up'));
        touchControls.down.addEventListener('click', () => setDirection('down'));
        touchControls.left.addEventListener('click', () => setDirection('left'));
        touchControls.right.addEventListener('click', () => setDirection('right'));
        touchControls.pause.addEventListener('click', togglePause);

        /**
         * Ajuste la taille du canvas pour l'adaptabilit√© mobile.
         * Assure que le canvas reste carr√© (500x500 pixels logiques)
         * tout en s'adaptant √† la taille du conteneur parent (qui est responsive).
         */
        function resizeCanvas() {
            // Uniquement si le canvas est visible (le jeu est lanc√©)
            if (canvas.style.display === 'block') {
                const containerWidth = gameContainer.offsetWidth;
                const size = Math.min(containerWidth, 500); // Limite √† 500px

                // Le canvas est toujours 500x500 pixels, mais sa taille d'affichage est ajust√©e
                canvas.style.width = `${size}px`;
                canvas.style.height = `${size}px`;
            }
        }
        
        // Initialisation et gestion du redimensionnement
        window.addEventListener('resize', resizeCanvas);
        window.onload = () => {
            // Dessine le menu et le record initial au chargement
            resizeCanvas(); 
            highScore = parseInt(localStorage.getItem('snakeHighScore') || 0);
            updateScoreDisplays();
            drawGame(); // Dessine la grille de fond
        };

        // Emp√™che le d√©filement par d√©faut lors de l'utilisation des touches directionnelles
        window.addEventListener("keydown", (e) => {
            if(["Space","ArrowUp","ArrowDown","ArrowLeft","ArrowRight"].indexOf(e.code) > -1) {
                if (canvas.style.display === 'block') {
                     e.preventDefault();
                }
            }
        }, false);
    </script>
</body>
</html>
